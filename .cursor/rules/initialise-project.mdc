---
description: ### 適用場景 (智能匹配) 當 AI Agent 需要進行任何類型的項目分析時，**智能關鍵字匹配系統**將自動觸發此規則：  #### 🔍 核心觸發關鍵字 - **項目分析類**: 項目分析、代碼審查、架構評估、技術債務分析 - **功能檢查類**: 功能完整性檢查、性能優化分析、安全性評估 - **用戶體驗類**: 用戶體驗分析、業務價值分析、技術風險分析 - **記憶庫類**: 記憶庫初始化、記憶庫更新、記憶差異檢測  #### 🎯 項目類型匹配 - **Web應用**: Web應用分析、前端分析、後端分析 - **移動應用**: 移動應用分析、iOS分析、Android分析 - **桌面應用**: 桌面應用分析、跨平台分析 - **後端服務**: 後端服務分析、API分析、微服務分析 - **數據分析**: 數據分析項目、機器學習分析 - **遊戲開發**: 遊戲開發分析、遊戲引擎分析  ### 🎯 分析目標 (優化版) 1. **智能環境檢測**: 自動確認專案根目錄和記憶庫位置 2. **智能文件過濾**: 自動過濾不相關文件 3. **高效記憶管理**: 智能創建和更新記憶文檔 4. **全面項目分析**: 涵蓋所有重要分析維度 5. **智能差異檢測**: 自動檢測記憶與項目狀態的差異 6. **數據驅動建議**: 基於分析結果提出改進建議  ---
globs: 
alwaysApply: false
---
globs: 
alwaysApply: false
---
# 🎯 項目初始化規則 (高效版 v3.0.0)

## 📋 快速參考指南

### 🔍 規則觸發決策樹
```mermaid
graph TD
    A[用戶請求] --> B{是否高優先級觸發?}
    B -->|是| K[觸發規則]
    B -->|否| C{是否次優先級觸發?}
    C -->|是| D{是否存在充分記憶庫?}
    C -->|否| J[不觸發規則]
    D -->|否| K
    D -->|是| E{最後更新是否超過30天?}
    E -->|是| K
    E -->|否| F{是否有重大項目變更?}
    F -->|是| K
    F -->|否| J
```

### 🚀 執行流程
```markdown
1. 智能規則觸發判斷 → 2. 記憶庫檢查 → 3. 智能記憶文檔整合與更新 → 4. 項目分析 → 5. 記憶創建/更新 → 6. 文檔驗證
```

---

## 🎯 規則觸發機制 (精確版)

### 1. 智能規則觸發決策系統
當 AI Agent 面對用戶請求時，需要執行智能決策流程來判斷是否應該觸發此規則：

#### 1.1 智能決策步驟
```python
# 智能規則觸發決策
def should_trigger_rule(user_query):
    # 步驟1: 檢查高優先級關鍵詞
    if contains_high_priority_keywords(user_query):
        return True
    
    # 步驟2: 檢查次優先級關鍵詞
    if contains_medium_priority_keywords(user_query):
        # 步驟3: 檢查記憶庫狀態
        memory_status = check_memory_bank_status()
        
        # 記憶庫不存在或不完整
        if memory_status["completeness"] < 0.7:
            return True
        
        # 記憶庫過期
        if memory_status["days_since_update"] > 30:
            return True
        
        # 檢測項目重大變更
        if detect_significant_project_changes():
            return True
    
    # 默認不觸發
    return False
```

#### 1.2 高優先級關鍵詞 (必觸發)
- **項目初始分析**: 初始化項目分析、首次分析、項目啟動分析
- **完整代碼審查**: 全面代碼審查、完整架構評估、系統級分析
- **記憶庫管理**: 記憶庫初始化、重建記憶庫、刷新項目記憶

#### 1.3 次優先級關鍵詞 (需進一步判斷)
- **項目分析類**: 項目分析、代碼審查、架構評估、技術債務分析
- **功能檢查類**: 功能完整性檢查、性能優化分析、安全性評估
- **用戶體驗類**: 用戶體驗分析、業務價值分析、技術風險分析

#### 1.4 不觸發情境 (明確禁止)
- 單個功能或模塊分析（非系統級）
- 簡單代碼問題修復
- 專項性能優化
- 局部功能實現
- 已存在充分記憶庫文檔且近期更新過時

### 2. 智能記憶庫檢查機制

#### 2.1 記憶庫完整性評估
```python
# 記憶庫完整性評估
def assess_memory_completeness():
    # 必要文檔清單
    essential_docs = [
        "project_overview",
        "technical_architecture", 
        "functional_modules",
        "development_progress"
    ]
    
    # 檢查文檔存在性和完整性
    existing_docs = list_memory_documents()
    completeness_score = 0
    
    for doc_type in essential_docs:
        doc = find_document_by_type(existing_docs, doc_type)
        if doc:
            completeness_score += assess_document_quality(doc)
        else:
            return 0.0  # 缺少必要文檔，完整性為0
    
    return completeness_score / len(essential_docs)
```

#### 2.2 項目變更檢測
```python
# 項目變更檢測
def detect_significant_project_changes():
    # 獲取最近一次記憶庫更新後的代碼變更
    last_memory_update = get_last_memory_update_date()
    code_changes = get_code_changes_since(last_memory_update)
    
    # 評估變更顯著性
    significance_score = assess_changes_significance(code_changes)
    
    return significance_score > SIGNIFICANT_CHANGE_THRESHOLD
```

---

## 🧠 統一記憶庫管理機制

### 0. 智能環境確認 (優化版)

#### 0.1 一鍵環境檢測
```python
# 智能環境檢測流程
def smart_environment_check():
    # 1. 專案根目錄智能檢測
    project_root = detect_project_root()
    
    # 2. 記憶庫路徑驗證
    memory_bank_path = validate_memory_bank(project_root)
    
    # 3. 環境隔離確認
    ensure_environment_isolation()
    
    # 4. 路徑安全性驗證
    validate_path_security()
    
    return project_root, memory_bank_path
```

### 1. 統一記憶庫文檔管理 (核心優化)

#### 1.1 核心記憶文檔體系
```python
# 統一記憶文檔體系
CORE_MEMORY_DOCUMENTS = {
    "project_overview": {
        "filename": "project_overview_{project_name}.md",
        "update_frequency": "major_changes",  # 只在重大變更時更新
        "required": True,
        "consolidate": False  # 不合併舊文檔
    },
    "technical_architecture": {
        "filename": "technical_architecture_{project_name}.md",
        "update_frequency": "major_changes",
        "required": True,
        "consolidate": False
    },
    "functional_modules": {
        "filename": "functional_modules_{project_name}.md",
        "update_frequency": "feature_changes",  # 功能變更時更新
        "required": True,
        "consolidate": False
    },
    "development_progress": {
        "filename": "development_progress_{project_name}.md",
        "update_frequency": "continuous",  # 持續更新
        "required": True,
        "consolidate": True  # 合併舊信息
    },
    "technical_debt": {
        "filename": "technical_debt_{project_name}.md",
        "update_frequency": "regular",  # 定期更新
        "required": False,
        "consolidate": True
    },
    "error_records": {
        "filename": "error_records_{project_name}.md",
        "update_frequency": "continuous",
        "required": False,
        "consolidate": True
    }
}
```

#### 1.2 智能文檔版本管理
```python
# 智能文檔版本管理
def smart_document_version_management():
    # 獲取所有現有記憶文檔
    existing_documents = list_memory_documents()
    
    # 對每種文檔類型執行版本管理
    for doc_type, config in CORE_MEMORY_DOCUMENTS.items():
        # 查找該類型的所有文檔版本
        doc_versions = find_documents_by_type(existing_documents, doc_type)
        
        if len(doc_versions) > 1:
            if config["consolidate"]:
                # 合併文檔
                consolidated_doc = consolidate_documents(doc_versions)
                save_consolidated_document(consolidated_doc, doc_type)
                
                # 刪除舊版本
                for old_doc in doc_versions:
                    delete_document(old_doc)
            else:
                # 保留最新版本，刪除舊版本
                latest_doc = get_latest_document(doc_versions)
                for old_doc in doc_versions:
                    if old_doc != latest_doc:
                        delete_document(old_doc)
```

#### 1.3 智能記憶更新決策
```python
# 智能記憶更新決策
def smart_memory_update_decision(doc_type, current_content):
    config = CORE_MEMORY_DOCUMENTS.get(doc_type)
    if not config:
        return False
    
    # 獲取現有文檔
    existing_doc = find_latest_document_by_type(doc_type)
    
    # 文檔不存在，必須創建
    if not existing_doc:
        return True
    
    # 根據更新頻率決定
    if config["update_frequency"] == "continuous":
        # 總是更新
        return True
    elif config["update_frequency"] == "major_changes":
        # 只在重大變更時更新
        return has_major_differences(current_content, existing_doc)
    elif config["update_frequency"] == "feature_changes":
        # 功能變更時更新
        return has_feature_changes(current_content, existing_doc)
    elif config["update_frequency"] == "regular":
        # 檢查上次更新時間
        last_update = get_document_last_update(existing_doc)
        return (datetime.now() - last_update).days > 30
    
    return False
```

#### 1.4 智能文檔合併
```python
# 智能文檔合併
def consolidate_documents(documents):
    # 按日期排序
    sorted_docs = sort_documents_by_date(documents)
    
    # 提取文檔類型
    doc_type = get_document_type(sorted_docs[0])
    
    # 根據文檔類型選擇合併策略
    if doc_type == "development_progress":
        return consolidate_progress_documents(sorted_docs)
    elif doc_type == "error_records":
        return consolidate_error_records(sorted_docs)
    elif doc_type == "technical_debt":
        return consolidate_technical_debt(sorted_docs)
    else:
        # 默認策略：使用最新文檔
        return sorted_docs[-1]
```

### 2. 智能文件過濾系統

#### 2.1 智能文件識別
```python
# 智能文件過濾系統
def smart_file_filter():
    # 強制忽略文件清單
    ignored_files = [
        'prd.md', 
        'prompt.md',
        'result.md',
        # 添加所有記憶庫文檔
        *get_all_memory_document_names()
    ]
    
    # 智能文件識別
    for file in project_files:
        if is_ignored_file(file, ignored_files):
            skip_file(file)
        else:
            process_file(file)
```

---

## 🔍 智能分析流程

### 1. 智能項目概覽分析

#### 1.1 智能基本信息收集
```python
# 智能基本信息收集
def smart_basic_info_collection():
    # 讀取項目文檔
    readme_info = read_project_readme()
    config_info = read_project_config()
    structure_info = analyze_project_structure()
    
    # 智能技術棧識別
    tech_stack = identify_tech_stack()
    
    # 智能依賴關係分析
    dependencies = analyze_dependencies()
    
    # 智能項目類型識別
    project_type = identify_project_type()
    
    return readme_info, config_info, structure_info, tech_stack, dependencies, project_type
```

### 2. 智能深度代碼分析 (精簡版)
```python
# 智能深度代碼分析
def smart_code_analysis():
    # 核心組件和模塊分析
    core_components = analyze_core_components()
    
    # 代碼質量檢查
    code_quality = assess_code_quality()
    
    # 關鍵依賴關係
    key_dependencies = analyze_key_dependencies()
    
    # 代碼結構評估
    code_structure = evaluate_code_structure()
    
    return {
        "core_components": core_components,
        "code_quality": code_quality,
        "key_dependencies": key_dependencies,
        "code_structure": code_structure
    }
```

### 3. 智能記憶生成與更新

#### 3.1 統一記憶生成流程
```python
# 統一記憶生成流程
def unified_memory_generation():
    # 獲取項目名稱
    project_name = get_project_name()
    
    # 獲取當前日期 (僅在新建時使用)
    current_date = datetime.now().strftime("%Y-%m-%d")
    
    # 處理每種核心文檔
    for doc_type, config in CORE_MEMORY_DOCUMENTS.items():
        # 生成文檔內容
        content = generate_document_content(doc_type)
        
        # 智能決定是否更新
        if smart_memory_update_decision(doc_type, content):
            # 獲取文件名 (不添加日期)
            filename = config["filename"].format(project_name=project_name)
            
            # 如果是持續更新類型，檢查是否需要合併
            if config["consolidate"]:
                existing_content = get_existing_document_content(doc_type)
                if existing_content:
                    content = merge_document_content(existing_content, content, doc_type)
            
            # 寫入文檔
            write_memory_document(filename, content)
```

#### 3.2 智能差異檢測
```python
# 智能差異檢測
def detect_smart_differences(old_content, new_content):
    # 結構化內容解析
    old_structure = parse_document_structure(old_content)
    new_structure = parse_document_structure(new_content)
    
    # 段落級別比較
    section_differences = compare_sections(old_structure, new_structure)
    
    # 關鍵信息比較
    key_info_differences = compare_key_information(old_structure, new_structure)
    
    # 差異程度評分 (0-1)
    difference_score = calculate_difference_score(section_differences, key_info_differences)
    
    return {
        "score": difference_score,
        "section_differences": section_differences,
        "key_info_differences": key_info_differences,
        "is_major_change": difference_score > 0.3
    }
```

---

## 🔧 優化後的記憶文檔模板

### 1. 項目概覽文檔
```markdown
# 項目概覽: {project_name}

## 基本信息
- **項目名稱**: {project_name}
- **最後更新**: {last_updated}
- **主要用途**: {main_purpose}
- **技術棧**: {tech_stack}

## 核心功能
{core_features}

## 關鍵模塊
{key_modules}

## 項目結構
{project_structure}

## 依賴關係
{dependencies}
```

### 2. 技術架構文檔
```markdown
# 技術架構: {project_name}

## 架構概述
{architecture_overview}

## 核心組件
{core_components}

## 數據流
{data_flow}

## 設計模式
{design_patterns}

## 技術選型
{technology_choices}

## 擴展性與限制
{scalability_and_limitations}
```

### 3. 功能模塊文檔
```markdown
# 功能模塊: {project_name}

## 模塊列表與功能
{modules_and_functions}

## 模塊間依賴
{module_dependencies}

## 核心業務邏輯
{core_business_logic}

## 主要接口
{main_interfaces}

## 數據模型
{data_models}
```

### 4. 開發進度文檔
```markdown
# 開發進度: {project_name}

## 當前狀態
{current_status}

## 已完成功能
{completed_features}

## 進行中功能
{in_progress_features}

## 待開發功能
{pending_features}

## 最近更新
{recent_updates}

## 迭代計劃
{iteration_plan}
```

---

## 📊 智能分析報告 (精簡版)

### 1. 執行摘要
```python
# 智能執行摘要
def generate_executive_summary():
    """生成簡潔明了的執行摘要"""
    return {
        "project_type": identify_project_type(),
        "tech_stack": identify_main_tech_stack(),
        "core_features": identify_core_features(),
        "architecture_type": identify_architecture_type(),
        "code_quality": assess_overall_code_quality(),
        "key_findings": extract_key_findings(),
        "recommendations": generate_key_recommendations()
    }
```

### 2. 記憶庫管理報告
```python
# 記憶庫管理報告
def generate_memory_management_report():
    """生成關於記憶庫管理的報告"""
    return {
        "documents_before": count_previous_documents(),
        "documents_after": count_current_documents(),
        "updated_documents": list_updated_documents(),
        "consolidated_documents": list_consolidated_documents(),
        "deleted_documents": list_deleted_documents(),
        "memory_completeness": calculate_memory_completeness()
    }
```

---

## 📋 智能規則執行檢查清單 (精簡版)

### 必要檢查項目
- [ ] 1. **規則觸發判斷** - 確認是否符合觸發條件
- [ ] 2. **環境檢測** - 專案路徑和記憶庫位置確認
- [ ] 3. **記憶庫狀態** - 檢查和評估現有記憶文檔
- [ ] 4. **文檔版本管理** - 整合和更新記憶文檔
- [ ] 5. **項目分析** - 進行必要的項目分析
- [ ] 6. **記憶更新** - 生成或更新核心記憶文檔
- [ ] 7. **結果驗證** - 確認記憶文檔質量和完整性

---

## 📋 版本更新記錄

### v3.0.0 (當前版本)
- ✅ **精確規則觸發系統**: 大幅優化規則觸發判斷機制
- ✅ **統一記憶庫管理**: 實現固定核心文檔結構
- ✅ **智能文檔版本控制**: 避免記憶庫過度膨脹
- ✅ **文檔合併機制**: 智能合併持續更新類文檔
- ✅ **差異檢測升級**: 更精確的文檔差異評估
- ✅ **精簡分析流程**: 減少不必要的深度分析
- ✅ **優化記憶文檔模板**: 提高信息密度和結構化程度

### v2.0.0 (先前版本)
- ✅ **智能關鍵字匹配系統**: 實現更智能的關鍵字匹配
- ✅ **快速執行流程**: 簡化冗長的檢查清單
- ✅ **智能調試模式**: 添加詳細的調試和日誌功能
- ✅ **智能錯誤處理**: 實現異常處理和自動重試
- ✅ **性能優化**: 優化執行流程，提高效率
- ✅ **智能化記憶庫管理**: 實現智能記憶差異檢測和同步
- ✅ **智能文件過濾系統**: 改進文件過濾機制
- ✅ **智能項目類型適配**: 實現不同項目類型的智能分析

---

## 🎯 規則調用指南

### 規則觸發時機
- ✅ **初始項目分析**: 首次分析項目時
- ✅ **記憶庫初始化**: 需要建立完整記憶庫時
- ✅ **重大項目變更**: 項目架構或核心功能發生重大變更時
- ✅ **記憶庫過時**: 記憶文檔超過30天未更新時
- ⚠️ **避免過度調用**: 局部功能分析或開發時無需調用

### 規則調用效益
- **記憶庫統一**: 維護核心一致的記憶文檔
- **記憶高效率**: 避免文檔爆炸和記憶碎片化
- **智能更新**: 只在必要時更新文檔
- **全局視角**: 提供項目整體分析