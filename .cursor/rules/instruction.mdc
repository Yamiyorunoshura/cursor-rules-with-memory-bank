---
description: 
globs: 
alwaysApply: true
---
# 🔄 規則優先級說明
## ⚠️ 重要提醒：優先級降低
**本規則文件優先級已降低，請優先查看 agent 自動請求的規則**

### 📋 規則使用順序
1. **第一優先級**: Agent 根據關鍵字自動請求的規則（如 fetch_rules 獲取的規則）
2. **第二優先級**: 用戶規則（user_rules）
3. **第三優先級**: 工作區規則（workspace_rules）
4. **第四優先級**: 本規則文件（instruction.mdc）- **僅作為備用參考**

### 🎯 使用指導
- **優先執行**: Agent 自動請求的規則和用戶規則
- **參考使用**: 本規則僅在沒有其他明確指導時使用
- **靈活應用**: 根據具體情況選擇最適合的規則組合

### 🔍 Agent 自動請求規則觸發條件
- **項目分析**: 當檢測到項目分析、代碼審查、架構評估等關鍵字時
- **PRD 撰寫**: 當檢測到 PRD 撰寫、需求文檔、產品規格等關鍵字時
- **測試相關**: 當檢測到測試分析、測試結果、測試覆蓋率等關鍵字時
- **其他專業領域**: 根據具體關鍵字自動觸發相應的專業規則

---

## 📋 核心開發原則

### 1. **任務複雜度判斷與思考策略**
- **複雜度評估**: 在每次修改前先判斷任務複雜度
- **思考工具選擇**: 根據複雜度選擇適當的思考策略
- **Sequential Thinking**: 複雜任務使用結構化思考
- **直接執行**: 簡單任務直接執行，無需過度思考

### 2. **提示詞解析與執行**
- **需求分析**: 仔細解析用戶提示詞的具體需求
- **功能分解**: 將複雜需求分解為可執行的開發任務
- **優先級排序**: 根據重要性和依賴關係排序開發任務
- **進度追蹤**: 持續更新開發進度並向用戶報告

### 3. **工具使用優先級**
- **文件操作**: 優先使用 `mcp_Desktop_Commander_*` 工具
- **代碼搜索**: 使用 `codebase_search` 進行語義搜索
- **精確搜索**: 使用 `grep_search` 進行精確匹配
- **文件讀取**: 使用 `read_file` 或 `mcp_Desktop_Commander_read_file`
- **代碼編輯**: 使用 `edit_file` 或 `search_replace`
- **思考工具**: 使用 `mcp_Sequential_Thinking_sequentialthinking` 進行複雜分析

### 4. **思考流程**
```
1. 任務複雜度判斷 → 2. 思考策略選擇 → 3. Sequential Thinking分析 → 4. 工具選擇與執行 → 5. 結果驗證與優化
```

### **Sequential Thinking使用指導**
```markdown
# 低複雜度任務 (直接執行)
- 跳過Sequential Thinking，直接使用工具執行
- 專注於快速完成任務

# 中複雜度任務 (3-5步思考)
- 使用Sequential Thinking進行結構化分析
- 重點分析影響範圍和執行策略
- 制定清晰的執行計劃
- 設置next_thought_needed=false確保完成

# 高複雜度任務 (8-12步深度思考)
- 使用Sequential Thinking進行全面分析
- 考慮多種實現方案和風險評估
- 深入分析問題本質和解決方案
- 制定詳細的執行計劃和備選方案
- 設置next_thought_needed=false確保完成
```

### 5. **錯誤處理策略**
- 遇到錯誤時，先分析錯誤原因
- 使用適當的工具重新嘗試
- 提供清晰的錯誤說明和解決方案
- 在錯誤解決後繼續執行原定計劃

### 6. **Sequential Thinking防卡住機制**
```markdown
# 防卡住原則
- 每次使用Sequential Thinking必須設置nextThoughtNeeded=false
- 避免無限循環思考，設定明確的思考步驟數
- 思考完成後立即轉向實際執行
- 如果思考超過預期時間，強制結束並開始執行

# 完成思考的關鍵設置
- nextThoughtNeeded=false: 告訴工具思考已完成
- thoughtNumber=totalThoughts: 確保是最後一步
- 設置缺一不可，確保思考真正結束

# 執行流程
1. 判斷複雜度 → 2. 決定是否使用Sequential Thinking
3. 如果使用：設定明確的思考步驟數 → 4. 執行思考 → 5. 設置nextThoughtNeeded=false
6. 立即轉向實際代碼執行 → 7. 驗證結果

# 緊急退出機制
- 如果Sequential Thinking卡住超過30秒，強制退出
- 直接使用其他工具開始執行
- 在執行過程中補充必要的分析

# 正確的完成思考調用
```python
mcp_Sequential_Thinking_sequentialthinking(
    thought="思考完成，準備開始執行",
    nextThoughtNeeded=false,
    thoughtNumber=5,
    totalThoughts=5
)
```
```

## 🧠 任務複雜度判斷框架

### **複雜度評估標準**
```markdown
# 低複雜度任務 (直接執行)
- 單一文件修改
- 簡單的文本替換
- 已知位置的代碼調整
- 文檔更新
- 配置修改

# 中複雜度任務 (簡單思考)
- 多文件關聯修改
- 功能擴展
- Bug修復
- 代碼重構
- 測試編寫

# 高複雜度任務 (Sequential Thinking)
- 架構重設計
- 新功能開發
- 系統整合
- 性能優化
- 安全加固
- 多模組協調
- 複雜業務邏輯實現
```

### **思考策略選擇**
```markdown
# 低複雜度 → 直接執行
- 跳過Sequential Thinking，直接使用工具
- 專注於快速完成任務
- 最小化思考開銷

# 中複雜度 → 結構化思考
- 使用Sequential Thinking進行3-5步分析
- 重點分析影響範圍和執行策略
- 制定清晰的執行計劃
- 評估風險和依賴關係

# 高複雜度 → 深度思考
- 使用Sequential Thinking進行8-12步分析
- 全面分析問題本質和解決方案
- 考慮多種實現方案和備選策略
- 深入評估風險、影響和資源需求
- 制定詳細的執行計劃和監控機制
```

## 🎯 提示詞解析與開發指導

### **提示詞分析框架**
```markdown
# 1. 需求識別
- 功能需求: 用戶想要實現什麼功能？
- 技術需求: 需要什麼技術棧或工具？
- 性能需求: 有什麼性能或效率要求？
- 兼容性需求: 需要與什麼系統集成？

# 2. 範圍界定
- 核心功能: 必須實現的功能
- 可選功能: 有時間可以添加的功能
- 邊界條件: 不包含在本次開發中的功能

# 3. 優先級排序
- 高優先級: 核心功能，必須完成
- 中優先級: 重要功能，應該完成
- 低優先級: 優化功能，有時間完成
```

### **開發任務分解**
```markdown
# 複雜需求分解
1. 分析現有代碼結構
2. 設計新功能架構
3. 實現核心功能
4. 添加錯誤處理
5. 更新相關文檔
6. 驗證功能完整性

# 簡單需求處理
1. 定位相關代碼
2. 進行必要修改
3. 驗證功能正確性
4. 更新相關文檔
```

### **提示詞執行指南**
```markdown
# 1. 立即響應階段
- 確認理解用戶需求
- 提供初步的實現計劃
- 詢問是否需要調整或補充

# 2. 分析階段
- 搜索相關的現有代碼
- 分析項目結構和依賴關係
- 確定實現策略和技術方案

# 3. 實現階段
- 按照優先級順序實現功能
- 使用適當的工具進行代碼編輯
- 保持代碼風格一致性

# 4. 驗證階段
- 檢查代碼語法正確性
- 確保與現有系統的兼容性
- 驗證功能邏輯完整性

# 5. 完成階段
- 提供完整的功能總結
- 說明如何使用新功能
- 提供後續改進建議
```

### **常見提示詞類型處理**
```markdown
# 功能開發提示詞
- 分析功能需求
- 設計實現方案
- 逐步實現功能
- 驗證功能完整性

# Bug修復提示詞
- 定位問題原因
- 分析影響範圍
- 實施修復方案
- 驗證修復效果

# 代碼優化提示詞
- 分析性能瓶頸
- 設計優化方案
- 實施優化措施
- 驗證優化效果

# 文檔更新提示詞
- 識別需要更新的文檔
- 收集相關信息
- 更新文檔內容
- 驗證文檔準確性
```

## 🛠️ MCP工具使用指南

### **文件系統操作**
```markdown
# 讀取文件
- 小文件: read_file(target_file, should_read_entire_file=True)
- 大文件: mcp_Desktop_Commander_read_file(path, offset=0, length=1000)
- 多文件: mcp_Desktop_Commander_read_multiple_files(paths)

# 寫入文件
- 新文件: edit_file(target_file, instructions, code_edit)
- 大文件: mcp_Desktop_Commander_write_file(path, content, mode='rewrite')
- 追加內容: mcp_Desktop_Commander_write_file(path, content, mode='append')

# 搜索文件
- 語義搜索: codebase_search(query, target_directories)
- 精確搜索: grep_search(query, include_pattern="*.py")
- 文件搜索: file_search(query)
```

### **代碼編輯最佳實踐**
```markdown
# 小修改
- 使用 edit_file 進行簡單的單文件修改
- 提供清晰的 instructions 說明修改目的

# 大修改
- 使用 search_replace 進行精確替換
- 包含足夠的上下文確保唯一性
- 分步驟進行複雜修改

# 批量修改
- 使用 mcp_Desktop_Commander_edit_block 進行手術式編輯
- 每次編輯專注於單一變更
- 保持編輯塊小於30行
```

### **目錄和文件管理**
```markdown
# 目錄操作
- 列出目錄: list_dir(relative_workspace_path)
- 創建目錄: mcp_Desktop_Commander_create_directory(path)
- 移動文件: mcp_Desktop_Commander_move_file(source, destination)

# 文件信息
- 獲取文件信息: mcp_Desktop_Commander_get_file_info(path)
- 搜索文件: mcp_Desktop_Commander_search_files(path, pattern)
```

### **Sequential Thinking工具使用**
```markdown
# 複雜度判斷後使用
- 低複雜度: 跳過Sequential Thinking，直接執行
- 中複雜度: 使用3-5步結構化思考分析
- 高複雜度: 使用8-12步深度思考分析

# 正確的Sequential Thinking MCP工具調用
- 工具名稱: mcp_Sequential_Thinking_sequentialthinking
- 必要參數: thought, nextThoughtNeeded, thoughtNumber, totalThoughts
- 可選參數: isRevision, revisesThought, branchFromThought, branchId, needsMoreThoughts

# 思考與執行轉換機制
- 思考完成後必須立即轉向實際執行
- 使用current_step中推薦的工具進行執行
- 不要繼續思考，直接調用推薦的工具
- 在執行過程中補充必要的分析

# 防卡住機制
- 必須設置nextThoughtNeeded=false確保思考完成
- 設定明確的totalThoughts數量
- 思考完成後立即轉向實際執行
- 避免在思考階段停留過久

# 執行優先原則
- 思考是準備，執行是核心
- 80%完成度即可開始執行
- 在執行中發現問題比在思考中完美更重要
- 快速迭代優於完美規劃

# Sequential Thinking參數說明
- thought: 當前思考步驟的內容
- nextThoughtNeeded: 是否需要更多思考步驟 (true/false)
- thoughtNumber: 當前思考步驟編號 (從1開始)
- totalThoughts: 預估總思考步驟數
- isRevision: 是否為修訂之前的思考 (true/false)
- revisesThought: 修訂哪個思考步驟 (步驟編號)
- branchFromThought: 從哪個思考步驟分支 (步驟編號)
- branchId: 分支標識符
- needsMoreThoughts: 是否需要更多思考步驟 (true/false)

# 使用示例
```python
# 開始思考
mcp_Sequential_Thinking_sequentialthinking(
    thought="分析用戶需求：用戶希望修改規則文檔以正確指導AI agent調用Sequential Thinking MCP工具",
    nextThoughtNeeded=true,
    thoughtNumber=1,
    totalThoughts=5
)

# 完成思考
mcp_Sequential_Thinking_sequentialthinking(
    thought="思考完成，準備開始執行",
    nextThoughtNeeded=false,
    thoughtNumber=5,
    totalThoughts=5
)
```
```

# 思考步驟結構 (中複雜度)
1. 問題理解與需求分析
2. 現有代碼結構和影響範圍分析
3. 解決方案設計和實現策略
4. 風險評估和依賴關係分析
5. 執行計劃制定和工具選擇
6. 設置nextThoughtNeeded=false完成思考

# 思考步驟結構 (高複雜度)
1. 問題本質理解和需求深度分析
2. 現有系統架構和代碼結構分析
3. 多種解決方案設計和比較
4. 實現策略制定和技術方案選擇
5. 風險評估、影響分析和資源需求
6. 執行計劃制定和監控機制設計
7. 工具選擇、使用策略和備選方案
8. 驗證策略、測試計劃和質量保證
9. 性能優化和安全性考慮
10. 文檔更新和知識管理
11. 後續維護和改進計劃
12. 總結和經驗教訓記錄
13. 設置nextThoughtNeeded=false完成思考
```

## 🔍 代碼分析策略

### **項目理解階段**
1. **項目結構分析**
   ```markdown
   - 使用 list_dir() 了解項目結構
   - 讀取 README.md 和配置文件
   - 分析主要模組和依賴關係
   ```

2. **代碼質量評估**
   ```markdown
   - 使用 codebase_search() 搜索關鍵功能
   - 檢查測試覆蓋率和代碼風格
   - 識別技術債務和改進機會
   ```

3. **功能分析**
   ```markdown
   - 搜索特定功能的實現
   - 分析API接口和數據流
   - 檢查錯誤處理和日誌記錄
   ```

### **開發階段**
1. **需求分析**
   ```markdown
   - 明確理解用戶需求
   - 識別相關的現有代碼
   - 制定實現策略
   ```

2. **代碼實現**
   ```markdown
   - 使用適當的工具進行代碼編輯
   - 保持代碼風格一致性
   - 添加必要的註釋和文檔
   ```

3. **功能驗證**
   ```markdown
   - 檢查代碼語法正確性
   - 確保與現有系統的兼容性
   - 驗證功能邏輯完整性
   ```

## 📊 工具選擇決策樹

### **任務複雜度判斷**
```
用戶請求？
├─ 單一文件修改 → 低複雜度
├─ 簡單文本替換 → 低複雜度
├─ 已知位置調整 → 低複雜度
├─ 多文件關聯 → 中複雜度
├─ 功能擴展 → 中複雜度
├─ Bug修復 → 中複雜度
├─ 架構重設計 → 高複雜度
├─ 新功能開發 → 高複雜度
└─ 系統整合 → 高複雜度
```

### **思考策略選擇**
```
複雜度判斷結果？
├─ 低複雜度 → 跳過Sequential Thinking，直接執行
├─ 中複雜度 → Sequential Thinking (3-5步結構化分析)
└─ 高複雜度 → Sequential Thinking (8-12步深度分析)
```

### **文件操作選擇**
```
需要讀取文件？
├─ 小文件 (< 1000行) → read_file()
├─ 大文件 (> 1000行) → mcp_Desktop_Commander_read_file()
└─ 多個文件 → mcp_Desktop_Commander_read_multiple_files()

需要編輯文件？
├─ 簡單修改 → edit_file()
├─ 精確替換 → search_replace()
└─ 手術式編輯 → mcp_Desktop_Commander_edit_block()

需要搜索代碼？
├─ 語義搜索 → codebase_search()
├─ 精確匹配 → grep_search()
└─ 文件搜索 → file_search()
```

### **開發任務選擇**
```
新功能開發？
├─ 分析現有代碼 → codebase_search()
├─ 創建新文件 → edit_file()
└─ 修改現有文件 → search_replace()

Bug修復？
├─ 定位問題 → grep_search()
├─ 分析代碼 → read_file()
└─ 修復代碼 → edit_file()

代碼重構？
├─ 分析影響範圍 → codebase_search()
├─ 批量修改 → mcp_Desktop_Commander_edit_block()
└─ 測試驗證 → run_terminal_cmd()

提示詞執行？
├─ 需求分析 → 解析用戶需求
├─ 任務分解 → 制定實現計劃
├─ 代碼實現 → 使用適當工具
└─ 功能驗證 → 檢查實現效果
```

## 🎯 開發最佳實踐

### **代碼編輯原則**
1. **保持一致性**
   - 遵循現有代碼風格
   - 使用一致的命名規範
   - 保持縮進和格式統一

2. **錯誤處理**
   - 添加適當的異常處理
   - 提供清晰的錯誤信息
   - 記錄重要的操作日誌

3. **文檔和註釋**
   - 為複雜邏輯添加註釋
   - 更新相關文檔
   - 提供使用示例

### **代碼質量保證**
1. **語法檢查**
   - 確保代碼語法正確
   - 檢查導入語句
   - 驗證變量定義

2. **風格檢查**
   - 保持代碼風格一致性
   - 檢查命名規範
   - 確保縮進正確

3. **兼容性檢查**
   - 確保與現有代碼兼容
   - 檢查依賴關係
   - 驗證接口一致性

## 🚀 高級開發技巧

### **Sequential Thinking MCP工具正確使用方法**
```markdown
# 工具名稱和參數
- 正確工具名稱: mcp_Sequential_Thinking_sequentialthinking
- 必要參數: thought, nextThoughtNeeded, thoughtNumber, totalThoughts
- 可選參數: isRevision, revisesThought, branchFromThought, branchId, needsMoreThoughts

# 基本使用流程
1. 判斷任務複雜度
2. 決定是否使用Sequential Thinking
3. 設定totalThoughts數量
4. 開始思考 (thoughtNumber=1, nextThoughtNeeded=true)
5. 繼續思考 (thoughtNumber=2,3,4..., nextThoughtNeeded=true)
6. 完成思考 (thoughtNumber=totalThoughts, nextThoughtNeeded=false)

# 完成思考的關鍵
- 最後一步必須設置nextThoughtNeeded=false
- thoughtNumber必須等於totalThoughts
- 思考完成後立即轉向實際執行

# 錯誤示例
❌ 錯誤: 使用舊的參數名稱 (next_thought_needed, remaining_steps)
❌ 錯誤: 不設置nextThoughtNeeded=false
❌ 錯誤: 思考完成後繼續思考而不是執行

# 正確示例
✅ 正確: 使用正確的參數名稱 (nextThoughtNeeded)
✅ 正確: 最後一步設置nextThoughtNeeded=false
✅ 正確: 思考完成後立即開始執行
```

### **Sequential Thinking執行轉換**
```markdown
# AI Agent執行指導
- 當Sequential Thinking完成時，必須立即轉向實際執行
- 使用current_step.recommended_tools中的工具進行執行
- 按照priority順序調用推薦的工具
- 不要繼續思考，直接開始執行

# 工具調用順序
1. 檢查current_step.recommended_tools
2. 按priority排序工具
3. 使用suggested_inputs中的參數
4. 執行工具並處理結果
5. 根據next_step_conditions判斷下一步

# 執行轉換檢查清單
- [ ] 設置nextThoughtNeeded=false
- [ ] 確保thoughtNumber=totalThoughts
- [ ] 立即調用current_step中的推薦工具
- [ ] 不要繼續思考或分析
- [ ] 在執行中補充必要的分析
```

### **批量操作**
```markdown
# 批量文件處理
- 使用 mcp_Desktop_Commander_read_multiple_files() 同時讀取多個文件
- 使用 mcp_Desktop_Commander_edit_block() 進行精確批量修改
- 使用 grep_search() 查找所有相關位置
```

### **性能優化**
```markdown
# 大文件處理
- 使用分塊讀取避免內存問題
- 使用增量編輯減少文件大小
- 優先使用高效的搜索工具
```

### **錯誤恢復**
```markdown
# 錯誤處理策略
- 保存原始文件備份
- 使用版本控制追蹤變更
- 提供回滾方案
```

### **Sequential Thinking最佳實踐**
```markdown
# 思考步驟設計
- 每個思考步驟專注於單一問題
- 避免在單一步驟中處理多個問題
- 使用清晰的邏輯連接詞
- 必須設置nextThoughtNeeded=false確保完成

# 思考與執行轉換
- 思考完成後必須立即轉向實際執行
- 使用current_step中推薦的工具進行執行
- 不要繼續思考，直接調用推薦的工具
- 在執行過程中補充必要的分析

# 工具整合
- 在思考過程中適時使用其他工具
- 將思考結果轉化為具體行動
- 驗證思考結果的可行性
- 思考完成後立即開始實際執行

# 防卡住策略
- 設定明確的思考時間限制
- 避免過度分析，適可而止
- 優先執行，後續優化
- 如果卡住，強制退出並開始執行

# 強制執行觸發條件
- 思考時間超過限制
- 連續3次思考無實質進展
- 思考內容重複或循環
- 用戶明確要求執行
```

## 📝 開發檢查清單

### **開始開發前**
- [ ] 判斷任務複雜度
- [ ] 選擇適當的思考策略
- [ ] 解析用戶提示詞需求
- [ ] 分解複雜需求為可執行任務
- [ ] 理解項目結構和架構
- [ ] 識別相關的現有代碼
- [ ] 制定實現策略
- [ ] 準備測試方案

### **開發過程中**
- [ ] 遵循代碼風格規範
- [ ] 添加必要的註釋
- [ ] 處理異常情況
- [ ] 保持代碼簡潔

### **完成開發後**
- [ ] 檢查代碼語法正確性
- [ ] 確保代碼風格一致性
- [ ] 更新相關文檔
- [ ] 驗證功能完整性
- [ ] 提供完整的功能總結
- [ ] 說明如何使用新功能
- [ ] 提供後續改進建議

## 🔧 常見問題解決

### **工具使用問題**
```markdown
Q: 文件讀取失敗？
A: 檢查文件路徑，使用絕對路徑，確認文件存在

Q: 搜索結果不準確？
A: 調整搜索關鍵詞，使用更精確的查詢，嘗試不同的搜索工具

Q: 編輯失敗？
A: 檢查文件權限，確認編輯內容格式正確，提供足夠的上下文

Q: Sequential Thinking何時使用？
A: 中複雜度任務使用3-5步結構化分析，高複雜度任務使用8-12步深度分析，低複雜度任務跳過Sequential Thinking直接執行

Q: Sequential Thinking卡住怎麼辦？
A: 設置nextThoughtNeeded=false強制完成思考，立即轉向實際執行，避免過度分析

Q: 如何避免Sequential Thinking無限循環？
A: 設定明確的totalThoughts數量，在最後一步設置nextThoughtNeeded=false，思考完成後立即開始執行

Q: AI Agent如何知道何時停止思考開始執行？
A: 當設置nextThoughtNeeded=false時，必須立即使用current_step.recommended_tools中的工具開始執行

Q: 為什麼AI Agent不按照推薦工具執行？
A: 必須在思考完成後立即調用current_step中的推薦工具，不要繼續思考，直接開始執行
```

### **開發問題**
```markdown
Q: 如何找到相關代碼？
A: 使用 codebase_search() 進行語義搜索，使用 grep_search() 進行精確搜索

Q: 如何進行批量修改？
A: 使用 mcp_Desktop_Commander_edit_block() 進行手術式編輯，分步驟進行

Q: 如何驗證修改？
A: 檢查代碼語法正確性，確保與現有系統兼容，驗證功能邏輯完整性

Q: 如何處理複雜的提示詞需求？
A: 使用Sequential Thinking進行深度分析，分解為多個小任務，按優先級順序執行

Q: 如何確保提示詞執行完整？
A: 使用檢查清單，逐步驗證每個功能點，確保代碼質量

Q: 如何處理模糊的需求？
A: 使用Sequential Thinking分析需求，主動詢問細節，提供多個實現選項

Q: 如何判斷任務複雜度？
A: 根據修改範圍、影響文件數量、技術難度、業務複雜度綜合評估
```

## 📚 參考資源

### **工具文檔**
- MCP Desktop Commander: 文件系統操作
- Codebase Search: 語義代碼搜索
- Grep Search: 精確文本搜索
- Edit File: 代碼編輯工具
- Sequential Thinking Tools: 結構化思考工具

### **最佳實踐**
- 保持代碼簡潔和可讀性
- 遵循現有的代碼風格
- 添加適當的錯誤處理
- 編寫清晰的文檔和註釋
- 根據任務複雜度選擇適當的思考策略
- **Sequential Thinking防卡住**: 必須設置nextThoughtNeeded=false，避免無限思考循環
- **執行轉換機制**: 思考完成後必須立即使用current_step.recommended_tools中的工具開始執行
- **執行優先原則**: 思考是準備，執行是核心，優先完成再優化

### **Sequential Thinking MCP工具使用總結**
```markdown
# 核心要點
1. 使用正確的工具名稱: mcp_Sequential_Thinking_sequentialthinking
2. 使用正確的參數名稱: nextThoughtNeeded (不是next_thought_needed)
3. 完成思考時必須設置: nextThoughtNeeded=false
4. 思考完成後立即轉向實際執行

# 關鍵檢查點
- [ ] 工具名稱正確
- [ ] 參數名稱正確
- [ ] 最後一步設置nextThoughtNeeded=false
- [ ] 思考完成後立即執行
- [ ] 避免無限循環思考

# 常見錯誤避免
- ❌ 不要使用舊的參數名稱
- ❌ 不要忘記設置nextThoughtNeeded=false
- ❌ 不要思考完成後繼續思考
- ❌ 不要忽略執行轉換機制
```
