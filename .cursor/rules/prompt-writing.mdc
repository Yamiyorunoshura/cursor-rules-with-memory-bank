---
description: 生成prompt；撰寫prompt - 自動調用場景：PRD文檔解析、result.md需求提取、需求分析、功能規格制定、技術要求定義、實現指導撰寫、驗收標準制定、測試要求規劃、風險控制設計、文檔要求定義、開發進度更新、項目路徑檢測、記憶庫掃描、PRD文件選擇、result.md文件檢測、智能內容生成、標準化模板應用、品質控制檢查、工具使用指導、最佳實踐應用、模組開發規劃、架構設計指導、接口定義、數據流設計、依賴關係分析、測試策略制定、性能要求定義、安全要求制定、兼容性要求、可維護性設計、可擴展性規劃、可重用性設計、可移植性考慮、可測試性設計、可讀性要求、可理解性設計、可修改性規劃、可調試性設計、可部署性考慮、可運維性設計、可監控性規劃、可告警性設計、可恢復性考慮、可備份性設計、可還原性規劃、可遷移性考慮、可升級性設計、可降級性規劃、可回滾性設計、可切換性考慮、可隔離性設計、可並行性規劃、可串行性設計、可異步性考慮、可同步性設計、可並發性規劃、可分佈性設計、可集中性考慮、可分散性設計、可聚合性規劃、可分解性設計、可組合性考慮、可拆分性設計、可合併性規劃、可分離性設計、可連接性考慮、可斷開性設計、可啟動性規劃、可停止性設計、可暫停性考慮、可恢復性設計、可重啟性規劃、可重置性設計、可清除性考慮、可清理性設計、可整理性規劃、可歸檔性設計、可備份性考慮、可還原性設計、可遷移性規劃、可升級性考慮、可降級性設計、可回滾性規劃、可切換性考慮、可隔離性設計、可並行性規劃、可串行性設計、可異步性考慮、可同步性設計、可並發性規劃、可分佈性設計、可集中性考慮、可分散性設計、可聚合性規劃、可分解性設計、可組合性考慮、可拆分性設計、可合併性規劃、可分離性設計、可連接性考慮、可斷開性設計、可啟動性規劃、可停止性設計、可暫停性考慮、可恢復性設計、可重啟性規劃、可重置性設計、可清除性考慮、可清理性設計、可整理性規劃、可歸檔性設計
globs: 
alwaysApply: false
---
# 🤖 AI Agent 智能提示詞生成規則

## 📋 目錄結構
1. [🎯 核心功能概述](mdc:#-核心功能概述)
2. [🔄 智能提示詞生成流程](mdc:#-智能提示詞生成流程)
3. [🛠️ 工具使用指南](mdc:#️-工具使用指南)
4. [📊 品質控制標準](mdc:#-品質控制標準)
5. [🎯 雙重需求模式指導](mdc:#-雙重需求模式指導)
6. [📝 智能實用模板](mdc:#-智能實用模板)
7. [🚀 最佳實踐](mdc:#-最佳實踐)

---

## 🎯 核心功能概述

### **主要功能**
- **雙重需求來源支持**: 支持從PRD文件或result.md文件提取需求
- **智能需求選擇**: 自動檢測和選擇最合適的需求來源
- **標準化模板生成**: 生成結構化的開發提示詞
- **文件管理**: 自動覆蓋現有的prompt.md文件
- **品質控制**: 確保生成的提示詞完整、準確、可執行

### **適用場景**
- **PRD驅動**: 新功能開發、功能擴展、架構設計
- **Result.md驅動**: 問題修復、性能改進、測試失敗處理

---

## 🔄 智能提示詞生成流程

### **階段一：需求來源檢測與解析**

#### 1.1 雙重需求來源檢測
```markdown
**檢測步驟**:
1. 使用 Desktop Commander 檢測專案根目錄
2. 掃描 memory_bank/ 目錄，檢測PRD和result.md文件
3. 識別包含 'prd' 關鍵字的 .md 文件
4. 識別包含 'result' 關鍵字的 .md 文件
5. 根據用戶需求選擇合適的需求來源文件

**工具使用**: mcp_Desktop_Commander_list_directory
```

#### 1.2 需求來源選擇策略
```markdown
**選擇邏輯**:
1. **用戶明確指定**: 優先使用用戶指定的需求來源
2. **PRD優先策略**: 新功能開發、功能擴展、架構設計
3. **Result優先策略**: 問題修復、性能改進、測試失敗處理
4. **智能檢測策略**: 自動檢測文件存在性和修改時間
5. **最新文件策略**: 選擇最新修改的文件
6. **內容完整性策略**: 選擇內容更完整的文件
```

#### 1.3 PRD內容解析
```markdown
**解析目標**: 提取項目名稱、核心需求、技術規格等關鍵信息
**工具使用**: mcp_Desktop_Commander_read_file
**解析內容**:
- 項目概述和業務目標
- 功能需求和技術規格
- 性能要求和安全要求
- 驗收標準和測試要求
```

#### 1.4 Result.md內容解析
```markdown
**解析目標**: 提取測試結果、失敗項目、改進需求等關鍵信息
**工具使用**: mcp_Desktop_Commander_read_file
**解析內容**:
- 測試概況和結果統計
- 失敗項目和問題分析
- 成功項目和穩定功能
- 改進需求和優化建議
```

### **階段二：智能內容生成**

#### 2.1 基於PRD的提示詞結構
```markdown
**標準模板**:
# [項目名稱] 開發提示詞

## 🎯 功能概述
- 核心需求: [從PRD提取的核心功能描述]
- 業務價值: [功能實現的業務價值和目標]
- 用戶場景: [主要使用場景和用戶流程]

## 📋 技術要求
- 功能規格: [主要功能、次要功能、可選功能]
- 技術規格: [具體的技術實現細節]
- 性能要求: [性能指標和限制]

## 🔧 實現指導
[分階段實現計劃]

## ✅ 驗收標準
[功能、性能、安全驗收標準]

## 🧪 測試要求
[單元測試、整合測試、性能測試要求]

## 🚨 風險控制
[技術風險和依賴風險控制措施]

## 📝 文檔要求
[代碼文檔和用戶文檔要求]
```

#### 2.2 基於Result.md的提示詞結構
```markdown
**標準模板**:
# [項目名稱] 測試結果驅動開發提示詞

## 🎯 測試結果分析
- 測試概況: [從result.md提取的測試概況]
- 成功項目: [成功通過的測試項目和功能]
- 失敗項目: [失敗的測試項目和需要修復的問題]
- 改進需求: [基於測試結果識別的改進需求]

## 📋 修復要求
- 緊急修復項目: [高、中、低優先級問題]
- 功能改進項目: [性能優化、穩定性提升、用戶體驗優化]
- 測試覆蓋率改進: [缺失測試、測試質量、自動化程度]

## 🔧 實現指導
- 階段1: 緊急問題修復
- 階段2: 功能改進實現
- 階段3: 測試質量提升
- 階段4: 驗證與回歸測試

## ✅ 驗收標準
- 修復驗收: [所有緊急問題已修復、功能改進已實現]
- 質量驗收: [測試通過率、性能指標、穩定性改善]
- 文檔更新驗收: [相關文檔已更新、測試報告已更新]

## 🧪 測試要求
- 回歸測試: [測試範圍和預期結果]
- 新增測試: [新增測試和測試數據]
- 性能測試: [性能測試場景和指標]

## 🚨 風險控制
- 修復風險: [風險點和控制措施]
- 回歸風險: [回歸風險和預防措施]

## 📝 文檔要求
- 修復文檔: [修復過程和結果記錄]
- 測試文檔: [測試計劃和結果報告]
```

#### 2.3 智能內容格式化
```markdown
**PRD格式化規則**:
1. 需求格式化: 將PRD中的需求點轉換為清晰的列表格式
2. 技術規格格式化: 將技術細節轉換為結構化的規格說明
3. 驗收標準格式化: 將驗收條件轉換為可測試的檢查清單
4. 實現指導格式化: 將實施計劃轉換為具體的實現步驟

**Result.md格式化規則**:
1. 測試結果格式化: 將測試結果轉換為清晰的問題列表
2. 修復需求格式化: 將失敗測試轉換為具體的修復任務
3. 改進需求格式化: 將測試發現的問題轉換為改進需求
4. 優先級格式化: 根據問題嚴重程度設置修復優先級
```

### **階段三：文件管理與保存**

#### 3.1 智能文件管理
```markdown
**操作步驟**:
1. 檢測專案根目錄
2. 檢查是否存在舊的 prompt.md 文件
3. 如果存在，直接覆蓋而非創建新的
4. 使用分塊寫入方式生成新的 prompt.md 文件
5. 確保文件內容完整且格式正確
6. 根據需求來源選擇合適的模板結構

**工具使用**: mcp_Desktop_Commander_write_file
```

#### 3.2 標準化文件命名
```markdown
**文件命名規範**:
- 主文件: prompt.md
- 儲存位置: 專案根目錄
- 覆蓋機制: 直接覆蓋現有文件，不創建備份
```

---

## 🛠️ 工具使用指南

### **1. Desktop Commander 工具優先使用**

#### 文件操作工具
- **讀取文件**: `mcp_Desktop_Commander_read_file` - 高效文件讀取
- **寫入文件**: `mcp_Desktop_Commander_write_file` - 分塊文件寫入（25-30行為一塊）
- **精確編輯**: `mcp_Desktop_Commander_edit_block` - 手術式代碼修改
- **目錄瀏覽**: `mcp_Desktop_Commander_list_directory` - 目錄結構查看

#### 代碼搜索工具
- **語義搜索**: `mcp_Desktop_Commander_search_code` - 快速代碼搜索
- **文件搜索**: `mcp_Desktop_Commander_search_files` - 文件名搜索
- **多文件讀取**: `mcp_Desktop_Commander_read_multiple_files` - 同時讀取多個文件

#### 進程管理工具
- **數據分析**: `mcp_Desktop_Commander_start_process` - 啟動 Python REPL 進行數據分析
- **交互式操作**: `mcp_Desktop_Commander_interact_with_process` - 交互式代碼執行
- **進程監控**: `mcp_Desktop_Commander_list_sessions` - 監控活動進程

### **2. Context7 工具使用**

#### 文檔查詢工具
- **庫文檔查詢**: `mcp_Context7_resolve-library-id` - 獲取準確的庫 ID
- **詳細文檔**: `mcp_Context7_get-library-docs` - 獲取詳細文檔
- **使用場景**: 在編寫代碼前自動查詢相關庫的最新文檔和最佳實踐

### **3. 備用工具**

#### 語義搜索
- `codebase_search` - 語義搜索
- `grep_search` - 精確文本搜索
- `edit_file` - 文件編輯
- `run_terminal_cmd` - 測試和部署

### **4. 動態項目檢測機制**
```markdown
**項目識別策略**:
1. 工作目錄檢測: 使用 Desktop Commander 檢測當前工作目錄
2. 項目結構驗證: 檢查目錄是否包含項目關鍵文件（main.py, cogs/, tests/ 等）
3. 記憶庫檢測: 檢查是否存在 memory_bank/ 目錄
4. PRD文件檢測: 檢查 memory_bank/ 目錄中是否存在 PRD 文件
5. 路徑確認: 確認檢測到的路徑為正確的項目根目錄

**檢測流程**:
1. 使用 `mcp_Desktop_Commander_list_directory` 檢測當前目錄結構
2. 檢查是否包含項目關鍵文件（main.py, cogs/, tests/, memory_bank/ 等）
3. 如果當前目錄不是項目根目錄，向上層目錄搜索直到找到項目根目錄
4. 驗證找到的目錄確實包含完整的項目結構
5. 確認 memory_bank/ 目錄存在且包含 PRD 文件
```

---

## 📊 品質控制標準

### **1. 提示詞品質指標**
- **完整性**: 涵蓋需求來源的所有要求，包括功能、性能、安全
- **準確性**: 技術規格準確無誤，包含具體的實現細節
- **可執行性**: 提示詞可直接用於開發，包含具體的步驟和示例
- **一致性**: 與專案規範保持一致，遵循統一的標準
- **可測試性**: 包含可測試的驗收標準和測試策略

### **2. 智能驗證檢查清單**
- [ ] 需求覆蓋率達到100%，包括所有功能點和優先級
- [ ] 技術規格明確具體，包含實現細節和示例
- [ ] 實現步驟邏輯合理，包含具體的指導和代碼示例
- [ ] 驗收標準可測量，包含具體的指標和測試方法
- [ ] 測試要求完整，包含單元測試、整合測試、性能測試
- [ ] 錯誤處理完善，包含異常處理和日誌記錄
- [ ] 文檔同步更新，包含代碼文檔和用戶文檔
- [ ] 風險控制措施具體，包含風險識別和控制策略
- [ ] 開發進度文檔更新要求明確，包含更新內容和工具使用
- [ ] 當基於result.md時，測試結果轉換為開發需求的準確性
- [ ] 當基於PRD時，功能需求提取為開發指導的完整性
- [ ] 需求來源選擇的合理性（PRD vs result.md）

### **3. 內容完整性檢查**
- [ ] 是否涵蓋需求來源（PRD或result.md）的所有功能點和優先級
- [ ] 是否包含所有技術要求和性能指標
- [ ] 是否考慮了完整的錯誤處理和日誌記錄
- [ ] 是否包含全面的測試要求和覆蓋率
- [ ] 是否考慮了安全性和兼容性要求
- [ ] 當基於result.md時，是否正確轉換測試結果為開發需求
- [ ] 當基於PRD時，是否正確提取功能需求為開發指導

### **4. 技術準確性檢查**
- [ ] 技術規格是否準確且包含具體實現細節
- [ ] API設計是否合理且包含完整的參數說明
- [ ] 數據結構定義是否清晰且符合實際需求
- [ ] 錯誤處理策略是否完善且包含具體的異常類型
- [ ] 性能要求是否具體且可測量

### **5. 可執行性檢查**
- [ ] 實現步驟是否邏輯合理且可測試
- [ ] 代碼示例是否正確且可直接使用
- [ ] 驗收標準是否可測量且包含具體指標
- [ ] 測試策略是否完整且包含具體的測試用例
- [ ] 風險控制措施是否具體且可執行

---

## 🎯 雙重需求模式指導

### **1. PRD驅動模式使用場景**
```markdown
**適用場景**:
- 新功能開發和設計
- 功能擴展和增強
- 架構重構和優化
- 系統整合和升級
- 業務流程改進

**使用方式**:
- 用戶明確要求基於PRD生成prompt
- 檢測到PRD文件存在且內容完整
- 用戶需求涉及新功能開發

**輸出特點**:
- 完整的開發指導文檔
- 詳細的功能規格說明
- 全面的測試要求
- 完整的驗收標準
```

### **2. Result.md驅動模式使用場景**
```markdown
**適用場景**:
- 測試失敗問題修復
- 性能問題改進
- 穩定性問題解決
- 用戶體驗優化
- 測試覆蓋率提升

**使用方式**:
- 用戶明確要求基於result.md生成prompt
- 檢測到result.md文件存在且包含測試結果
- 用戶需求涉及問題修復或改進

**輸出特點**:
- 針對性的修復指導
- 具體的問題分析
- 詳細的修復計劃
- 完整的驗證方法
```

### **3. 智能模式選擇指導**
```markdown
**自動選擇邏輯**:
1. 用戶明確指定: 優先使用用戶指定的需求來源
2. 文件存在性檢查: 檢查PRD和result.md文件的存在性
3. 修改時間比較: 選擇最新修改的文件作為需求來源
4. 內容完整性評估: 選擇內容更完整的文件
5. 場景匹配: 根據用戶需求場景選擇合適的模式

**選擇建議**:
- 開發新功能 → 選擇PRD驅動模式
- 修復現有問題 → 選擇Result.md驅動模式
- 性能優化 → 選擇Result.md驅動模式
- 架構改進 → 選擇PRD驅動模式
```

### **4. 混合模式處理**
```markdown
**當兩個文件都存在時**:
1. 需求整合: 將PRD的功能需求和result.md的問題需求進行整合
2. 優先級協調: 協調不同來源需求的優先級
3. 實現計劃整合: 制定統一的實現計劃
4. 驗收標準整合: 整合不同來源的驗收標準

**處理策略**:
- 以PRD為主要需求來源
- 將result.md中的問題作為改進需求
- 整合兩者的驗收標準
- 制定綜合的實現計劃
```

---

## 📝 智能實用模板

### **1. 智能標準提示詞模板**
```markdown
# [功能名稱] 開發提示詞

## 🎯 功能概述
### 核心需求
[從PRD提取的核心功能描述]

### 業務價值
[功能實現的業務價值和目標]

### 用戶場景
[主要使用場景和用戶流程]

## 📋 技術要求
### 功能規格
- **主要功能**: [核心功能點]
- **次要功能**: [輔助功能點]
- **可選功能**: [擴展功能點]

### 技術規格
- **數據結構**: [具體的數據結構定義]
- **API設計**: [API接口設計和參數]
- **業務邏輯**: [核心業務邏輯流程]
- **錯誤處理**: [錯誤處理策略]

### 性能要求
- **響應時間**: [預期響應時間]
- **並發處理**: [並發用戶數]
- **資源使用**: [內存、CPU限制]

## 🔧 實現指導
### 階段1: [基礎功能實現]
[具體實現指導和代碼示例]

### 階段2: [核心功能實現]
[具體實現指導和代碼示例]

### 階段3: [優化與測試]
[性能優化和測試指導]

### 階段4: [文檔更新與進度記錄]
- 更新相關代碼文檔和用戶文檔
- 更新開發進度文檔 `memory_bank/development_progress_discord_adr_bot.md`
- 記錄開發成果和技術成就
- 沉澱開發經驗和教訓

## ✅ 驗收標準
### 功能驗收
- [ ] [功能驗收條件1]
- [ ] [功能驗收條件2]

### 性能驗收
- [ ] [性能驗收條件1]
- [ ] [性能驗收條件2]

### 安全驗收
- [ ] [安全驗收條件1]
- [ ] [安全驗收條件2]

### 開發進度文檔更新驗收
- [ ] 開發進度文檔已更新，記錄本次開發成果
- [ ] 技術成就和性能指標已同步更新
- [ ] 里程碑和版本信息已記錄
- [ ] 開發經驗和教訓已沉澱到文檔中

## 🧪 測試要求
### 單元測試
- [測試範圍1] - [預期覆蓋率]
- [測試範圍2] - [預期覆蓋率]

### 整合測試
- [測試場景1] - [測試數據]
- [測試場景2] - [測試數據]

### 性能測試
- [性能測試場景1]
- [性能測試場景2]

## 📝 開發進度更新要求

### 開發完成後必須更新
- **開發進度文檔**: 完成開發後必須更新 `memory_bank/development_progress_discord_adr_bot.md`
- **更新內容**: 記錄本次開發的功能、修復的問題、達成的里程碑
- **更新時間**: 在功能測試通過後立即更新
- **更新格式**: 遵循現有文檔格式，保持一致性

### 更新檢查清單
- [ ] 更新當前開發階段狀態
- [ ] 記錄完成的功能和修復的問題
- [ ] 更新技術成就和性能指標
- [ ] 更新進行中任務的進度
- [ ] 更新計劃中功能的狀態
- [ ] 記錄新的里程碑和版本信息
- [ ] 更新質量指標和用戶體驗評估
- [ ] 記錄開發過程中的經驗和教訓

### 更新工具使用
- **文件讀取**: 使用 `mcp_Desktop_Commander_read_file` 讀取現有進度文檔
- **文件編輯**: 使用 `mcp_Desktop_Commander_edit_block` 進行精確更新
- **內容驗證**: 確保更新內容準確且符合文檔格式
- **版本追蹤**: 記錄更新時間和更新原因

## 🚨 風險控制
### 技術風險
- [風險點1] - [控制措施]
- [風險點2] - [控制措施]

### 依賴風險
- [依賴風險1] - [備選方案]
- [依賴風險2] - [備選方案]

### 文檔更新風險
- **進度文檔未及時更新** - 控制措施：在開發完成後立即更新，建立檢查清單
- **文檔內容不準確** - 控制措施：使用 Desktop Commander 工具進行精確更新和驗證
- **文檔格式不一致** - 控制措施：遵循現有文檔格式，保持一致性

## 📝 文檔要求
### 代碼文檔
- [文檔要求1]
- [文檔要求2]

### 用戶文檔
- [文檔要求1]
- [文檔要求2]

### 開發進度文檔更新
- **必須更新**: 完成開發後必須更新 `memory_bank/development_progress_discord_adr_bot.md`
- **更新內容**: 
  - 記錄本次開發完成的功能和修復的問題
  - 更新當前開發階段狀態和里程碑
  - 更新技術成就和性能指標
  - 記錄開發過程中的經驗和教訓
- **更新時間**: 在功能測試通過後立即更新
- **更新工具**: 使用 Desktop Commander 工具進行文件讀取和編輯
- **格式要求**: 遵循現有文檔格式，保持一致性
```

### **2. 智能模組開發模板**
```markdown
# [模組名稱] 模組開發

## 🏗️ 架構設計
### 模組職責
[模組的主要職責和邊界]

### 模組結構
```
[模組結構圖或描述]
```

### 接口定義
```python
# 主要接口
def main_function(param1: type, param2: type) -> return_type:
    """
    功能描述
    
    Args:
        param1: 參數描述
        param2: 參數描述
        
    Returns:
        返回值描述
        
    Raises:
        ExceptionType: 異常描述
    """
    pass
```

## 📊 數據流設計
### 輸入數據
- [數據類型1] - [數據格式和驗證]
- [數據類型2] - [數據格式和驗證]

### 處理邏輯
- [處理步驟1] - [具體實現]
- [處理步驟2] - [具體實現]

### 輸出數據
- [輸出格式1] - [數據結構]
- [輸出格式2] - [數據結構]

## 🔗 依賴關係
### 前置依賴
- [依賴模組1] - [依賴原因]
- [依賴模組2] - [依賴原因]

### 後續影響
- [影響模組1] - [影響範圍]
- [影響模組2] - [影響範圍]

### 外部依賴
- [外部庫1] - [版本要求]
- [外部庫2] - [版本要求]

## 🧪 測試策略
### 單元測試
- [測試用例1] - [測試數據和預期結果]
- [測試用例2] - [測試數據和預期結果]

### 整合測試
- [測試場景1] - [測試流程]
- [測試場景2] - [測試流程]

### 性能測試
- [性能測試1] - [性能指標]
- [性能測試2] - [性能指標]
```

---

## 🚀 最佳實踐

### **1. 工具使用最佳實踐**
- **優先使用 Desktop Commander**: 在所有文件操作、代碼編輯和進程管理中優先使用
- **自動文檔查詢**: 在編寫代碼時自動使用 Context7 獲取最新庫文檔
- **智能搜索策略**: 結合使用多種搜索工具進行全面的代碼和文檔搜索
- **進程管理**: 使用進程管理工具進行數據分析和測試執行

### **2. 內容生成最佳實踐**
- **雙重需求驅動**: 支持PRD驅動和result.md驅動兩種模式
- **智能需求選擇**: 根據用戶需求或文件狀態自動選擇合適的需求來源
- **模組化思維**: 將複雜需求分解為可管理的模組和階段
- **測試驅動**: 以測試要求指導實現設計，確保可測試性
- **風險預控**: 提前識別和控制實現風險，準備備選方案
- **結果導向**: 當基於result.md時，以測試結果為導向制定修復和改進計劃

### **3. 品質控制最佳實踐**
- **完整性檢查**: 確保涵蓋所有必要的功能點和技術要求
- **準確性驗證**: 確保技術規格準確且包含具體實現細節
- **可執行性測試**: 確保提示詞可直接用於開發，包含具體步驟
- **一致性維護**: 確保與專案規範保持一致，遵循統一標準

### **4. 智能特殊情況處理**
- **複雜功能處理**: 智能分解需求，分階段實現，依賴管理，風險控制
- **現有功能修改**: 影響評估，向後兼容，測試策略，文檔更新
- **新模組開發**: 架構設計，接口定義，數據流設計，測試計劃
- **測試結果驅動修復**: 問題優先級排序，修復策略制定，回歸測試設計，進度追蹤
- **混合需求處理**: 需求整合，優先級協調，實現計劃整合，驗收標準整合

### **5. 智能提示詞撰寫技巧**
- **雙重需求來源**: 支持從PRD或result.md開始，根據用戶需求選擇合適的基礎
- **智能需求選擇**: 自動檢測和選擇最合適的需求來源文件
- **模組化思維**: 將複雜需求分解為可管理的模組和階段
- **測試驅動**: 以測試要求指導實現設計，確保可測試性
- **迭代優化**: 根據實際情況不斷優化提示詞和實現策略
- **風險預控**: 提前識別和控制實現風險，準備備選方案
- **結果導向**: 當基於result.md時，以測試結果為導向制定具體的修復計劃

### **6. 智能常見問題避免**
- **避免模糊描述**: 使用具體明確的描述和具體的指標
- **避免技術跳躍**: 確保技術規格可執行，包含具體的實現細節
- **避免忽略測試**: 始終包含完整的測試要求和覆蓋策略
- **避免架構衝突**: 確保與現有架構兼容，遵循統一的設計模式
- **避免忽略風險**: 提前識別和控制實現風險，準備應對措施
- **避免需求來源混淆**: 明確區分PRD需求和result.md測試結果，選擇合適的處理方式
- **避免測試結果誤解**: 正確理解result.md中的測試結果，準確轉換為開發需求

---

## 📋 自動化執行指令

### **動態項目路徑檢測與需求來源檢測**
當用戶要求生成prompt時，AI應自動執行以下流程：

1. **動態檢測當前項目路徑**: 
   - 使用 Desktop Commander 的 `list_directory` 工具檢測當前工作目錄
   - 自動識別項目根目錄（包含 main.py, cogs/, tests/ 等關鍵文件的目錄）
   - 驗證該路徑包含正確的項目文件結構
   - 避免使用 URL 編碼的目錄路徑

2. **掃描記憶庫**: 使用 Desktop Commander 自動檢測當前項目的 `memory_bank/` 目錄中的所有文件
3. **需求來源選擇**: 
   - 檢測PRD文件和result.md文件的存在性
   - 根據用戶需求或文件修改時間選擇合適的需求來源
   - 如果用戶明確指定，優先使用指定的需求來源
4. **解析需求內容**: 使用 Desktop Commander 讀取並解析選定的需求文件內容
5. **檢查舊文件**: 檢查當前項目路徑下是否存在 `prompt.md` 文件，如果存在則直接覆蓋
6. **生成新Prompt**: 基於選定的需求來源生成標準化的 `prompt.md` 文件
7. **驗證完整性**: 確保生成的prompt包含所有必要的信息
8. **路徑驗證**: 最終確認文件儲存於正確的項目路徑下

### **標準化文件管理**
- **文件名標準化**: 所有prompt文件統一命名為 `prompt.md`
- **動態路徑標準化**: 使用 Desktop Commander 工具動態檢測並使用當前項目的正確路徑
- **自動備份機制**: 覆蓋舊文件前自動創建時間戳備份
- **版本追蹤**: 記錄prompt文件的生成歷史和變更原因
- **錯誤檢測**: 在儲存前檢測是否為正確的項目路徑，避免儲存到錯誤目錄
- **通用性**: 支持任何項目的記憶庫目錄結構

### **智能內容生成**
- **雙重需求驅動**: 支持基於PRD文件或result.md文件生成prompt
- **智能需求選擇**: 根據用戶需求或文件狀態自動選擇合適的需求來源
- **結構化輸出**: 使用標準化的模板結構確保一致性
- **內容完整性**: 確保包含功能需求、技術規格、實現指導、驗收標準等所有必要部分
- **動態路徑驗證**: 使用 Desktop Commander 工具動態驗證當前項目的正確路徑和文件操作
- **錯誤預防**: 在生成過程中持續檢查路徑正確性，避免儲存到錯誤目錄
- **通用性**: 支持任何項目的PRD結構和記憶庫組織方式
- **進度文檔更新**: 確保生成的prompt包含開發進度文檔更新要求
- **測試結果整合**: 當基於result.md時，將測試結果轉換為具體的開發需求

---

## 📁 文件儲存規範
- **動態項目識別**: 由本規則產生的所有 prompt.md 檔案，必須儲存於專案根目錄下的 memory_bank/ 目錄
- **自動路徑檢測**: 使用 Desktop Commander 工具自動檢測專案根目錄路徑
- **項目驗證**: 在儲存前必須驗證專案根目錄包含正確的項目文件（如 main.py, cogs/, tests/ 等）
- **禁止錯誤儲存**: 禁止將 prompt.md 儲存於 URL 編碼目錄或其他非本專案目錄
- **目錄檢查**: 若專案根目錄下的 memory_bank/ 目錄不存在，需自動建立後再儲存
- **路徑確認**: 使用 Desktop Commander 工具確認正確的專案根目錄路徑後再進行文件操作
- **文檔管理**: 生成的prompt註明不需要生成一份歸檔文件
- **需求來源標記**: 在生成的prompt中明確標記需求來源（基於PRD或基於result.md）
- **覆蓋機制**: 直接覆蓋現有的prompt.md文件，不創建備份文件
